var ImageLoader, ImageLoaderImg, PropTypes, React, ReactLoaderMixin, Status, createFactory, hasSize, id, img, merge, noscript, renderToStaticMarkup, span, _ref,
  __slice = [].slice;

React = require('react');

merge = require('xtend');

ReactLoaderMixin = require('react-loadermixin');

PropTypes = React.PropTypes;

_ref = React.DOM, span = _ref.span, img = _ref.img, noscript = _ref.noscript;

Status = {
  PENDING: 'pending',
  LOADING: 'loading',
  LOADED: 'loaded',
  FAILED: 'failed'
};

hasSize = function(i) {
  return (i.naturalWidth + i.naturalHeight === 0) || (i.width + i.height === 0);
};

renderToStaticMarkup = function(el) {
  return (React.renderToStaticMarkup || React.renderComponentToStaticMarkup)(el);
};

id = function(x) {
  return x;
};

createFactory = function(cls) {
  return (React.createFactory || id)(cls);
};

ImageLoaderImg = createFactory(React.createClass({
  displayName: 'ImageLoaderImage',
  getInitialState: function() {
    return {
      isInitialRender: true
    };
  },
  componentDidMount: function() {
    return this.setState({
      isInitialRender: false
    });
  },
  handleLoad: function() {
    var args, image, _base;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (!this.isMounted()) {
      return;
    }
    image = this.refs.image;
    if ('naturalWidth' in image && !hasSize(image)) {
      return this.handleError(new Error("Image <" + image.src + "> could not be loaded."));
    } else {
      return typeof (_base = this.props).onLoad === "function" ? _base.onLoad.apply(_base, args) : void 0;
    }
  },
  handleError: function() {
    var args, _base;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return typeof (_base = this.props).onError === "function" ? _base.onError.apply(_base, args) : void 0;
  },
  renderImg: function() {
    return img(merge(this.props, {
      ref: 'image',
      onLoad: this.handleLoad,
      onError: this.handleError
    }));
  },
  render: function() {
    var html;
    if (this.state.isInitialRender) {
      html = renderToStaticMarkup(noscript(null, this.renderImg()));
      return span({
        style: {
          display: 'none'
        },
        dangerouslySetInnerHTML: {
          __html: html
        }
      });
    } else {
      return this.renderImg();
    }
  }
}));

module.exports = ImageLoader = React.createClass({
  displayName: 'ImageLoader',
  mixins: [ReactLoaderMixin],
  propTypes: {
    wrapper: PropTypes.func,
    preloader: PropTypes.func
  },
  getInitialState: function() {
    return {
      status: Status.PENDING
    };
  },
  getDefaultProps: function() {
    return {
      wrapper: span,
      loader: ImageLoaderImg
    };
  },
  componentWillReceiveProps: function(nextProps) {
    if (this.props.src !== nextProps.src) {
      return this.setState({
        status: nextProps.src ? Status.LOADING : Status.PENDING
      });
    }
  },
  getClassName: function() {
    var className;
    className = "imageloader " + this.state.status;
    if (this.props.className) {
      className += " " + this.props.className;
    }
    return className;
  },
  getImgProps: function() {
    var props;
    props = merge(this.props, {
      style: merge(this.props.style, {
        display: this.state.status === Status.LOADED ? null : 'none'
      })
    });
    delete props.wrapper;
    delete props.preloader;
    delete props.children;
    return props;
  },
  loaderDidLoad: function() {
    return this.setState({
      status: Status.LOADED
    });
  },
  loaderDidError: function() {
    return this.setState({
      status: Status.FAILED
    });
  },
  renderChildren: function() {
    if (Array.isArray(this.props.children)) {
      return this.props.children.slice(0);
    } else {
      return [this.props.children];
    }
  },
  render: function() {
    var wrapperArgs, _ref1;
    wrapperArgs = [
      {
        className: this.getClassName()
      }
    ];
    if (this.props.src) {
      wrapperArgs.push(this.renderLoader(ImageLoaderImg, this.getImgProps()));
    }
    if (this.props.preloader && this.state.status !== Status.LOADED && this.state.status !== Status.FAILED) {
      wrapperArgs.push(this.props.preloader());
    }
    if (this.state.status === Status.FAILED) {
      wrapperArgs = wrapperArgs.concat(this.renderChildren());
    }
    return (_ref1 = this.props).wrapper.apply(_ref1, wrapperArgs);
  }
});
